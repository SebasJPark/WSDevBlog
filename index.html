<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sebastian Park Devblog</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            padding-bottom: 60px;
            background-color: #f5f5f5;
        }

        header {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }

        .accordion {
            cursor: pointer;
            background-color: #eee;
            padding: 10px;
            border: none;
            text-align: left;
            outline: none;
            font-size: 18px;
            transition: background-color 0.2s;
            margin-bottom: 5px;
        }

        .accordion:hover {
            background-color: #ccc;
        }

        .container {
            width: 80%;
            margin: 20px auto;
            margin-bottom: 60px;
            background-color: #d4d4d4;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .log-header {
            background-color: #444; /* Dark background for contrast */
            color: white; /* White text for readability */
            text-align: center; /* Center the text */
            padding: 20px; /* Add some padding for spacing */
            margin-bottom: 20px; /* Space between header and logs */
            border-radius: 10px; /* Rounded corners for a smoother look */
        }

        .panel {
            padding: 0 18px;
            background-color: rgb(224, 224, 224);
            display: none;
            overflow: hidden;
            margin-bottom: 10px;
        }

        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            bottom: 0;
            width: 100%;
        }
        pre {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre-wrap; /* Allows the code to wrap if needed */
            word-wrap: break-word;
        }

        code {
            font-family: Consolas, "Courier New", monospace;
            color: #d63384; /* Makes code stand out with color */
        }
    </style>
</head>
<body>

<header>
    <h1>WolverineSoft Devblog: Sebastian Park</h1>
    <p>Programming | sebasti@umich.edu</p>
</header>

<div class="container">
    <div class="panel log-header"></div>
        <h2>Weekly Logs</h2>
    <button class="accordion">Week 0: Setup</button>
    <div class="panel">
        <h2>Week 0</h2>
        <p>Date: September 25, 2024</p>
        <p>Not much this week, just got this site up and running, looking forward to working on this more!<br>On another note, I need to make sure videos work so have a random video of an Axl Low combo in GGS</p>
    
        <video width="560" height="315" controls>
            <source src="videos/gaming.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>
    </div>
    <br>
    <button class="accordion">Week 2: Planning and Prototypes</button>
    <div class="panel">
        <h2>Week 2</h2>
        <p>Date: October 13, 2024</p>
        <p>As with most projects, choosing a topic was a pretty difficult task. Throughout a couple meetings and a lot of documentation, we finally managed to settle down on one choice, a side-scroller in the same style as Castle Crashers, a Hack n' slash with depth.
            <br>In terms of time spent this week, a considerable amount was spent in meetings. Our team has literally 0 times where we can all meet in person, so a lot of my time was spent trying to figure out a solid schedule for us to follow, and even more trying to come to a consensus on what to create. We spent ~4 hours over two weeks in official studio meetings, and outside we spent around 2.
            <br>
            <br>My time during the first week was mainly dedicated to research of games, at the time side-scroller types such as Dead Cells and Katana Zero, with some research on Hyperlight Drifter as well. This all was around 8 hours of playing these games and taking notes on what I thought were important elements that we should add to our games. 
            <br>
            <br>For the research itself, I took it upon myself to get ahead on organizing our team, which meant that we wanted really good documentation. My way of doing this was to format documents on Notion to give easy and intuitive access to anything people needed on any form, be it a team member or an advisor that wants to check in on our progress. This took around 3 hours to complete as a conservative estimate, as getting to learn Notion and getting all the documents we needed set up took considerable effort. On top of that I really just like things looking nice so a lot of time was spent making things look nice, something that I hope pays off when we need to look back at docs in the future.
            <br>
            <br>The second week consisted more of preparing to start out work on the actual product itself. Since I haven't played a game like we intend to create before, I spent a bit of time figuring out the ins and outs of the genre. I found there was a demo of Castle Crashers on Steam, so, combined with watching gameplay videos on Youtube, I spent about an hour researching things like the general gameplay loop and combat within the game.
            <br>
            <br>After that Zane (the other programming member on our team) and I decided to start creating a quick draft of how we want to implement the gameplay, but couldn't come to an agreement. I had believed that a strict 2D implementation would be more effective, while he believed that a 3D implentation using an isometric camera would be more effective, so we agreed to spend a few days each on our implementations to see what one we should move forward with.
            <br>
            <br>Before starting the prototype, I wanted to make sure I understood state machines, as suggest by the studio president, so I spent a few hours watching tutorials to understand when and how to use them. Starting the project, I did my best to implement a state machine for the player (and a very very basic enemy, just chasing the player and patrolling), though since it was a prototype without access to anything like even animations yet, it was extremely limited, essentially only having idling, running, jumping, and attacking states. Eventually, after a considerable amount of time spent trying to figure out factors like jumping or platforming in 2D I realized that, yes, 3D is probably better. The 2D prototype is most likely going to get scrapped, which is a "waste" of a good 4 hours of my life, but I think at the very least I can reimplement the state machinery I used for player movement quite easily in 3D so we can start our project with good structure.
            <br>
            <br>Time Overview:
            <br>Studio Meetings: 4 Hours
            <br>Team Meetings: 2 Hours
            <br>Genre Research: 8 Hours
            <br>Notion Documentation: 3 Hours
            <br>Game Research (Castle Crashers): 1 Hour
            <br>Unity State Machine Research & Creation: 7 Hours
            <br>Prototyping: 4 Hours
            <br>Overall Time: 28 Hours
            <br>
            <!-- <br>(Not much that can be displayed in video/image format, unless pictures of games I played or code snippets count?) -->
            <br>
            </p>
            <button class="accordion">Example code from state machine</button>
            <div class="panel">
                <pre><code>
                    using System.Collections;
                    using System.Collections.Generic;
                    using UnityEngine;

                    public abstract class State : MonoBehaviour
                    {
                        protected Core core;
                        public bool isComplete {get; protected set;} // wanna access, don't want to show in the editor because it's annoying
                        protected float startTime;
                        public float time => Time.time - startTime;


                        protected Rigidbody2D rb => core.rb;
                        protected Animator animator => core.animator;

                        public StateMachine machine;
                        protected State parent;
                        public State state => machine.state;

                        public virtual void Enter() {}
                        public virtual void Do() {}
                        public virtual void FixedDo() {}
                        public virtual void Exit() {}
                        
                        public void DoBranch(){
                            Do();
                            state?.DoBranch(); // Call do on state below
                        }
                        public void FixedDoBranch(){
                            FixedDo();
                            state?.FixedDoBranch(); // Call do on state below
                        }



                        protected void Set(State newState, bool force = false){
                            machine.Set(newState, force); // here so we don't need to machine.Set every time
                        }
                        public void SetCore(Core _core){
                            machine = new StateMachine();
                            core = _core;
                        }

                        public void Initialise(){
                            isComplete = false;
                            startTime = Time.time;
                        }
                    }

                </code></pre>
                <pre><code>
                    using System.Collections;
                    using System.Collections.Generic;
                    using UnityEngine;

                    public class StateMachine
                    {
                        // Start is called before the first frame update
                        public State state;

                        public void Set(State newState, bool force = false){
                            if(state != newState || force){
                                state?.Exit(); // make sure it aint null
                                state = newState;
                                state.Initialise();
                                state.Enter();
                            }
                        }
                    }

                </code></pre>
                <pre><code>
                    using System.Collections;
                    using System.Collections.Generic;
                    using UnityEngine;

                    public class PlayerMovement : Core {

                        public RunState runState;
                        public IdleState idleState;
                        public JumpState jumpState;
                        public BoxCollider2D groundCheck;
                        public LayerMask groundMask;

                        //movement properties
                        public float acceleration;
                        [Range(0f, 1f)]
                        public float groundDecay;
                        public float maxSpeed;

                        //variables
                        public float xInput;
                        public float yInput;

                        void Start(){
                            SetupInstances();
                            machine.Set(idleState);
                        }

                        // Update is called once per frame
                        void Update() {
                            CheckInput();
                            HandleJump();

                            SelectState();
                            
                            machine.state.Do();
                        }

                        void SelectState(){

                            if(groundSensor.grounded){
                                if (xInput == 0 && yInput == 0){
                                    machine.Set(idleState);
                                }
                                else{
                                    machine.Set(runState);
                                }
                            } 
                            else{
                                machine.Set(jumpState);
                            }

                            
                        }
                        void FixedUpdate() {
                            HandleMovement();
                            ApplyFriction();
                        }

                        void CheckInput() {
                            xInput = Input.GetAxis("Horizontal");
                            yInput = Input.GetAxis("Vertical");
                        }

                        void HandleMovement() {
                            if (Mathf.Abs(xInput) > 0){
                                float increment = xInput * acceleration;
                                float newSpeedX = Mathf.Clamp(rb.velocity.x + increment, -maxSpeed, maxSpeed);
                                rb.velocity = new Vector2(newSpeedX, rb.velocity.y);
                                FaceInput();
                            }
                            if (Mathf.Abs(yInput) > 0){
                                float increment = yInput * acceleration;
                                float newSpeedY = Mathf.Clamp(rb.velocity.y + increment, -maxSpeed, maxSpeed);
                                rb.velocity = new Vector2(rb.velocity.x, newSpeedY);
                            }
                            rb.velocity = rb.velocity.magnitude > maxSpeed ? rb.velocity.normalized * maxSpeed : rb.velocity;

                        }

                        void FaceInput() {
                            float direction = Mathf.Sign(xInput);
                            transform.localScale = new Vector3(direction, 1, 1);
                        }

                        void HandleJump() {
                            if (Input.GetButtonDown("Jump") && groundSensor.grounded) {
                                return; // Has to change for 3D
                            }
                        }

                        

                        void ApplyFriction() {
                            if (groundSensor.grounded && xInput == 0) {
                                rb.velocity =  new Vector2(rb.velocity.x*groundDecay, rb.velocity.y);
                            }
                            if (groundSensor.grounded && yInput == 0) {
                                rb.velocity = new Vector2(rb.velocity.x, rb.velocity.y * groundDecay);
                            }
                        }

                        // Need a function for getting damaged and attacking, new states bb

                    }

                </code></pre>
            </div>
            

    </div>
</div>

<footer>
    <p>Graphic Design is my passion</p>
</footer>

<script>
    var acc = document.getElementsByClassName("accordion");
    for (var i = 0; i < acc.length; i++) {
        acc[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var panel = this.nextElementSibling;
            if (panel.style.display === "block") {
                panel.style.display = "none";
            } else {
                panel.style.display = "block";
            }
        });
    }
</script>

</body>
</html>
